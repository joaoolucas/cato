/// Bitcoin Ground-Truth Test Vectors
///
/// These tests are generated by a Bitcoin-compatible Script interpreter
/// (scripts/generate_bitcoin_vectors.py) with OP_CAT re-enabled.
///
/// Each test verifies that Cato produces IDENTICAL byte-for-byte output
/// to the Bitcoin reference implementation. This proves behavioral compatibility.
///
/// Generated from: test_vectors/bitcoin_ground_truth.json

use crate::vm::{ScriptVMTrait, VMError};
use crate::opcodes::{OP_ADD, OP_CAT, OP_DUP, OP_VERIFY};

/// Helper to create ByteArray from bytes
fn bytes_to_bytearray(bytes: Span<u8>) -> ByteArray {
    let mut result: ByteArray = "";
    let mut i: usize = 0;
    while i < bytes.len() {
        result.append_byte(*bytes.at(i));
        i += 1;
    };
    result
}

/// Helper to compare ByteArray with expected bytes byte-for-byte
fn assert_bytearray_eq_exact(actual: @ByteArray, expected: Span<u8>, test_name: ByteArray) {
    assert!(
        actual.len() == expected.len(),
        "GROUND TRUTH FAIL [{}]: length mismatch {} vs {}",
        test_name,
        actual.len(),
        expected.len()
    );
    let mut i: usize = 0;
    while i < expected.len() {
        let actual_byte = actual.at(i).unwrap();
        let expected_byte = *expected.at(i);
        assert!(
            actual_byte == expected_byte,
            "GROUND TRUTH FAIL [{}]: byte {} mismatch: got {} expected {}",
            test_name,
            i,
            actual_byte,
            expected_byte
        );
        i += 1;
    };
}

// ============================================
// OP_CAT Ground Truth Tests
// ============================================

/// cat_hello_world: Concatenate 'hello' and 'world'
/// Bitcoin: 68656c6c6f + 776f726c64 = 68656c6c6f776f726c64
#[test]
fn test_btc_cat_hello_world() {
    let mut stack: Array<ByteArray> = array![];
    // "hello" = 68656c6c6f
    stack.append(bytes_to_bytearray(array![0x68, 0x65, 0x6c, 0x6c, 0x6f].span()));
    // "world" = 776f726c64
    stack.append(bytes_to_bytearray(array![0x77, 0x6f, 0x72, 0x6c, 0x64].span()));

    let script: Array<u8> = array![OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_cat_hello_world should succeed");
    assert!(vm.stack.len() == 1, "should have one element");

    // Expected: 68656c6c6f776f726c64 = "helloworld"
    let expected: Array<u8> = array![
        0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64
    ];
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "cat_hello_world");
}

/// cat_empty_left: Empty string + 'abc' = 'abc'
/// Bitcoin: "" + 616263 = 616263
#[test]
fn test_btc_cat_empty_left() {
    let mut stack: Array<ByteArray> = array![];
    stack.append("");
    stack.append(bytes_to_bytearray(array![0x61, 0x62, 0x63].span()));

    let script: Array<u8> = array![OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_cat_empty_left should succeed");
    let expected: Array<u8> = array![0x61, 0x62, 0x63];
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "cat_empty_left");
}

/// cat_empty_right: 'abc' + empty = 'abc'
/// Bitcoin: 616263 + "" = 616263
#[test]
fn test_btc_cat_empty_right() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(bytes_to_bytearray(array![0x61, 0x62, 0x63].span()));
    stack.append("");

    let script: Array<u8> = array![OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_cat_empty_right should succeed");
    let expected: Array<u8> = array![0x61, 0x62, 0x63];
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "cat_empty_right");
}

/// cat_both_empty: Two empty strings
/// Bitcoin: "" + "" = ""
#[test]
fn test_btc_cat_both_empty() {
    let mut stack: Array<ByteArray> = array![];
    stack.append("");
    stack.append("");

    let script: Array<u8> = array![OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_cat_both_empty should succeed");
    assert!(vm.stack.len() == 1, "should have one element");
    assert!(vm.stack.at(0).len() == 0, "result should be empty string");
}

/// cat_binary_with_nulls: Binary data with null bytes preserved
/// Bitcoin: 00ff00 + ff00ff = 00ff00ff00ff
#[test]
fn test_btc_cat_binary_with_nulls() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(bytes_to_bytearray(array![0x00, 0xff, 0x00].span()));
    stack.append(bytes_to_bytearray(array![0xff, 0x00, 0xff].span()));

    let script: Array<u8> = array![OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_cat_binary_with_nulls should succeed");
    let expected: Array<u8> = array![0x00, 0xff, 0x00, 0xff, 0x00, 0xff];
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "cat_binary_with_nulls");
}

/// cat_single_bytes: Concatenate single bytes
/// Bitcoin: 01 + 02 = 0102
#[test]
fn test_btc_cat_single_bytes() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(bytes_to_bytearray(array![0x01].span()));
    stack.append(bytes_to_bytearray(array![0x02].span()));

    let script: Array<u8> = array![OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_cat_single_bytes should succeed");
    let expected: Array<u8> = array![0x01, 0x02];
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "cat_single_bytes");
}

/// cat_all_byte_values: All 256 byte values (0x00-0xff) preserved
/// Bitcoin: [00-7f] + [80-ff] = [00-ff]
#[test]
fn test_btc_cat_all_byte_values() {
    // Create first half: 0x00-0x7f (128 bytes)
    let mut elem_a: ByteArray = "";
    let mut i: u16 = 0;
    while i < 128 {
        elem_a.append_byte(i.try_into().unwrap());
        i += 1;
    };

    // Create second half: 0x80-0xff (128 bytes)
    let mut elem_b: ByteArray = "";
    let mut j: u16 = 128;
    while j < 256 {
        elem_b.append_byte(j.try_into().unwrap());
        j += 1;
    };

    let mut stack: Array<ByteArray> = array![];
    stack.append(elem_a);
    stack.append(elem_b);

    let script: Array<u8> = array![OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_cat_all_byte_values should succeed");
    assert!(vm.stack.at(0).len() == 256, "result should be 256 bytes");

    // Verify each byte value is preserved exactly
    let result = vm.stack.at(0);
    let mut k: u16 = 0;
    while k < 256 {
        let expected_byte: u8 = k.try_into().unwrap();
        let actual_byte = result.at(k.into()).unwrap();
        assert!(
            actual_byte == expected_byte,
            "byte {} mismatch: got {} expected {}",
            k,
            actual_byte,
            expected_byte
        );
        k += 1;
    };
}

/// cat_max_size_520: Maximum valid concatenation (260+260=520 bytes)
/// Bitcoin: Successfully concatenates to exactly 520 bytes
#[test]
fn test_btc_cat_max_size_520() {
    // Create 260-byte elements matching the Python script
    let mut elem_a: ByteArray = "";
    let mut i: u32 = 0;
    while i < 260 {
        elem_a.append_byte((i % 256).try_into().unwrap());
        i += 1;
    };

    let mut elem_b: ByteArray = "";
    let mut j: u32 = 0;
    while j < 260 {
        elem_b.append_byte(((j + 128) % 256).try_into().unwrap());
        j += 1;
    };

    let mut stack: Array<ByteArray> = array![];
    stack.append(elem_a);
    stack.append(elem_b);

    let script: Array<u8> = array![OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_cat_max_size_520 should succeed");
    assert!(vm.stack.at(0).len() == 520, "result should be exactly 520 bytes");

    // Verify first 260 bytes
    let result = vm.stack.at(0);
    let mut k: u32 = 0;
    while k < 260 {
        let expected: u8 = (k % 256).try_into().unwrap();
        assert!(result.at(k.into()).unwrap() == expected, "first half byte mismatch");
        k += 1;
    };

    // Verify second 260 bytes
    let mut l: u32 = 0;
    while l < 260 {
        let expected: u8 = ((l + 128) % 256).try_into().unwrap();
        assert!(result.at((260 + l).into()).unwrap() == expected, "second half byte mismatch");
        l += 1;
    };
}

/// cat_exceeds_max_size: 261+261=522 bytes exceeds MAX_SCRIPT_ELEMENT_SIZE
/// Bitcoin: Fails with "result too large"
#[test]
fn test_btc_cat_exceeds_max_size() {
    let mut elem_a: ByteArray = "";
    let mut elem_b: ByteArray = "";
    let mut i: u32 = 0;
    while i < 261 {
        elem_a.append_byte((i % 256).try_into().unwrap());
        elem_b.append_byte((i % 256).try_into().unwrap());
        i += 1;
    };

    let mut stack: Array<ByteArray> = array![];
    stack.append(elem_a);
    stack.append(elem_b);

    let script: Array<u8> = array![OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    let result = vm.execute();
    assert!(result.is_err(), "btc_cat_exceeds_max should fail");
    assert!(result.unwrap_err() == VMError::ElementTooLarge, "should be ElementTooLarge");
}

/// cat_underflow_empty: OP_CAT with empty stack
/// Bitcoin: Fails with "stack underflow"
#[test]
fn test_btc_cat_underflow_empty() {
    let stack: Array<ByteArray> = array![];
    let script: Array<u8> = array![OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    let result = vm.execute();
    assert!(result.is_err(), "btc_cat_underflow_empty should fail");
    assert!(result.unwrap_err() == VMError::StackUnderflow, "should be StackUnderflow");
}

/// cat_underflow_one: OP_CAT with only one element
/// Bitcoin: Fails with "stack underflow"
#[test]
fn test_btc_cat_underflow_one() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(bytes_to_bytearray(array![0xde, 0xad, 0xbe, 0xef].span()));

    let script: Array<u8> = array![OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    let result = vm.execute();
    assert!(result.is_err(), "btc_cat_underflow_one should fail");
    assert!(result.unwrap_err() == VMError::StackUnderflow, "should be StackUnderflow");
}

/// cat_chain_4_elements: Chain [a,b,c,d] with 3 CATs
/// Bitcoin: 61 + 62 + 63 + 64 = 61626364 ("abcd")
/// Execution order: CAT(c,d)->cd, CAT(b,cd)->bcd, CAT(a,bcd)->abcd
#[test]
fn test_btc_cat_chain_4_elements() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(bytes_to_bytearray(array![0x61].span())); // 'a'
    stack.append(bytes_to_bytearray(array![0x62].span())); // 'b'
    stack.append(bytes_to_bytearray(array![0x63].span())); // 'c'
    stack.append(bytes_to_bytearray(array![0x64].span())); // 'd'

    let script: Array<u8> = array![OP_CAT, OP_CAT, OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_cat_chain should succeed");
    assert!(vm.stack.len() == 1, "should have one element");

    // Expected: 61626364 = "abcd"
    let expected: Array<u8> = array![0x61, 0x62, 0x63, 0x64];
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "cat_chain_4_elements");
}

/// cat_with_dup: DUP then CAT doubles string
/// Bitcoin: 414243 DUP CAT = 414243414243 ("ABCABC")
#[test]
fn test_btc_cat_with_dup() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(bytes_to_bytearray(array![0x41, 0x42, 0x43].span())); // "ABC"

    let script: Array<u8> = array![OP_DUP, OP_CAT];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_cat_with_dup should succeed");
    // Expected: 414243414243 = "ABCABC"
    let expected: Array<u8> = array![0x41, 0x42, 0x43, 0x41, 0x42, 0x43];
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "cat_with_dup");
}

// ============================================
// OP_ADD Ground Truth Tests
// ============================================

/// add_2_plus_3: 2 + 3 = 5
/// Bitcoin: 02 + 03 = 05
#[test]
fn test_btc_add_2_plus_3() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(bytes_to_bytearray(array![0x02].span()));
    stack.append(bytes_to_bytearray(array![0x03].span()));

    let script: Array<u8> = array![OP_ADD];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_add_2_plus_3 should succeed");
    let expected: Array<u8> = array![0x05];
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "add_2_plus_3");
}

/// add_zero_left: 0 + 42 = 42
/// Bitcoin: "" (zero) + 2a = 2a
#[test]
fn test_btc_add_zero_left() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(""); // 0 is encoded as empty
    stack.append(bytes_to_bytearray(array![0x2a].span())); // 42

    let script: Array<u8> = array![OP_ADD];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_add_zero_left should succeed");
    let expected: Array<u8> = array![0x2a];
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "add_zero_left");
}

/// add_negative: -5 + 10 = 5
/// Bitcoin: 85 (-5) + 0a (10) = 05 (5)
#[test]
fn test_btc_add_negative() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(bytes_to_bytearray(array![0x85].span())); // -5 (0x05 | 0x80)
    stack.append(bytes_to_bytearray(array![0x0a].span())); // 10

    let script: Array<u8> = array![OP_ADD];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_add_negative should succeed");
    let expected: Array<u8> = array![0x05];
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "add_negative");
}

/// add_two_negatives: -3 + -7 = -10
/// Bitcoin: 83 (-3) + 87 (-7) = 8a (-10)
#[test]
fn test_btc_add_two_negatives() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(bytes_to_bytearray(array![0x83].span())); // -3
    stack.append(bytes_to_bytearray(array![0x87].span())); // -7

    let script: Array<u8> = array![OP_ADD];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_add_two_negatives should succeed");
    let expected: Array<u8> = array![0x8a]; // -10
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "add_two_negatives");
}

/// add_cancel_to_zero: 5 + -5 = 0
/// Bitcoin: 05 + 85 = "" (zero)
#[test]
fn test_btc_add_cancel_to_zero() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(bytes_to_bytearray(array![0x05].span())); // 5
    stack.append(bytes_to_bytearray(array![0x85].span())); // -5

    let script: Array<u8> = array![OP_ADD];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_add_cancel_to_zero should succeed");
    // Zero is encoded as empty bytearray in Bitcoin
    assert!(vm.stack.at(0).len() == 0, "result should be empty (zero)");
}

/// add_127_plus_1: 127 + 1 = 128
/// Bitcoin: 7f + 01 = 8000 (128 needs 2 bytes to avoid sign bit confusion)
#[test]
fn test_btc_add_127_plus_1() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(bytes_to_bytearray(array![0x7f].span())); // 127
    stack.append(bytes_to_bytearray(array![0x01].span())); // 1

    let script: Array<u8> = array![OP_ADD];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_add_127_plus_1 should succeed");
    // 128 = 0x80, but that would look negative, so Bitcoin uses 0x8000 (little-endian: 80 00)
    let expected: Array<u8> = array![0x80, 0x00];
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "add_127_plus_1");
}

/// add_256_plus_256: 256 + 256 = 512
/// Bitcoin: 0001 + 0001 = 0002
#[test]
fn test_btc_add_256_plus_256() {
    let mut stack: Array<ByteArray> = array![];
    // 256 in little-endian = 0x00 0x01
    stack.append(bytes_to_bytearray(array![0x00, 0x01].span()));
    stack.append(bytes_to_bytearray(array![0x00, 0x01].span()));

    let script: Array<u8> = array![OP_ADD];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_add_256_plus_256 should succeed");
    // 512 in little-endian = 0x00 0x02
    let expected: Array<u8> = array![0x00, 0x02];
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "add_256_plus_256");
}

// ============================================
// Combined Script Ground Truth Tests
// ============================================

/// script_push_cat: PUSH 'AB' PUSH 'CD' CAT
/// Bitcoin script: 024142024344 7e -> expected: 41424344
#[test]
fn test_btc_script_push_cat() {
    // Script: PUSH_2 'A''B' PUSH_2 'C''D' OP_CAT
    let script: Array<u8> = array![
        0x02, 0x41, 0x42, // PUSH_2 "AB"
        0x02, 0x43, 0x44, // PUSH_2 "CD"
        OP_CAT
    ];

    let mut vm = ScriptVMTrait::new(script);
    assert!(vm.execute().is_ok(), "btc_script_push_cat should succeed");

    let expected: Array<u8> = array![0x41, 0x42, 0x43, 0x44]; // "ABCD"
    assert_bytearray_eq_exact(vm.stack.at(0), expected.span(), "script_push_cat");
}

/// cat_verify_truthy: CAT produces truthy result, VERIFY passes
/// Bitcoin: [01, 02] CAT VERIFY -> empty stack (success)
#[test]
fn test_btc_cat_verify_truthy() {
    let mut stack: Array<ByteArray> = array![];
    stack.append(bytes_to_bytearray(array![0x01].span()));
    stack.append(bytes_to_bytearray(array![0x02].span()));

    let script: Array<u8> = array![OP_CAT, OP_VERIFY];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    assert!(vm.execute().is_ok(), "btc_cat_verify_truthy should succeed");
    assert!(vm.stack.len() == 0, "stack should be empty after VERIFY");
}

/// cat_verify_falsy: CAT of empties is falsy, VERIFY fails
/// Bitcoin: ["", ""] CAT VERIFY -> error
#[test]
fn test_btc_cat_verify_falsy() {
    let mut stack: Array<ByteArray> = array![];
    stack.append("");
    stack.append("");

    let script: Array<u8> = array![OP_CAT, OP_VERIFY];
    let mut vm = ScriptVMTrait::new_with_stack(script, stack);

    let result = vm.execute();
    assert!(result.is_err(), "btc_cat_verify_falsy should fail");
    assert!(result.unwrap_err() == VMError::ScriptFailed, "should be ScriptFailed");
}
